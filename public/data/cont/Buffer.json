{
  "name": "Buffer",
  "cont": "## 1. 概念\n\n`Buffer`对象用于表示固定长度的字节序列。许多 Node.js API 都支持 `Buffer` 。它是 `Uint8Array` 类的子类，Node.js API 在支持 `Buffer` 的地方也接受纯 `Uint8Array` 。它在全局作用域内可用，但仍然建议显式引用它。\n\n## 2. 特点\n\n- 大小固定\n- 性能好，直接操作内存\n- 每个元素大小为1字节\n\n## 3. 使用\n\n### 3.1 创建\n\n- `Buffer.alloc(size: number, fill?: string | Uint8Array | number, encoding?: BufferEncoding): Buffer`\n\n      创建一个长度为 size 的 Buffer，以 fill 填充，以 encoding 编码。 fill 默认为0。\n\n- `Buffer.allocUnsafe(size: number): Buffer`\n\n      以这种方式创建的 Buffer 实例的底层内存没有被初始化。新创建的 Buffer 的内容未知，可能包含敏感数据。\n\n- `Buffer.from`\n\n```js\nimport { Buffer } from 'node:buffer';\n\n/**\n\n * integer[]\n\n * 元素值为 0 - 255，超过则截断\n\n */\n\nconst buf1 = Buffer.from([0x68, 0x65, 0x6c, 0x6c, 0x6f]);\n\n/**\n\n * arrayBuffer, byteOffset?, length?\n\n * arrayBuffer 为 <ArrayBuffer>、<SharedArrayBuffer>，例如 TypedArray 的 buffer 属性。\n\n * byteOffset 和 length 参数指定了 arrayBuffer 中与 Buffer 共享的内存范围。\n\n */\n\nconst arr = new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f]);\n\nconst buf2 = Buffer.from(arr.buffer, 2, 3); // 取后三个字符\n\nfor (let i = 0; i < arr.length; i++) arr[i] += 1;\n\nconsole.log(buf2.toString()); // 输出 mmp\n\n/**\n\n * Buffer | Unit8Array\n\n * 相当于复制 Buffer，不共享内存\n\n */\n\nconst _buf3 = Buffer.alloc(5, 'hello');\n\nconst buf3 = Buffer.from(_buf3);\n\n/**\n\n * object, offsetOrEncoding?, length?\n\n * object 必须支持 valueOf() 或 Symbol.toPrimitive\n\n */\n\n//支持 valueOf()\n\nconst buf4a = Buffer.from(new String('hello'));\n\n//支持 Symbol.toPrimitive，hint 传参'string'\n\nconst buf4b = Buffer.from(\n  new (class {\n    [Symbol.toPrimitive](hint) {\n      if (hint === 'number') return 10;\n\n      if (hint === 'string') return 'hello';\n\n      return true;\n    }\n  })(),\n\n  'utf8',\n);\n\n/**\n\n * string, encoding?\n\n */\n\nconst buf5 = Buffer.from('hello', 'ascii');\n```\n"
}