{
  "name": "path",
  "cont": "```js\nimport path from 'node:path';\n\n  \n\n// 注：当前工作目录为 'C:\\Users\\a\\Desktop\\NodeStudy'\n\n  \n\n// path.sep返回当前系统的路径分隔符，POSIX为'/'，Win为'\\'\n\n'path\\\\to\\\\file.txt'.split(path.sep); // [ 'path', 'to', 'file.txt' ]\n\n  \n\n// path.delimiter返回当前系统的路径定界符，POSIX为':'，Win为';'\n\nprocess.env.PATH.split(path.delimiter);\n\n// ['C:\\\\Windows\\\\system32', 'C:\\\\Windows', ... ]\n\n  \n\n// 返回路径的最后一部分，并删除 `suffix` 后缀名（区分大小写）\n\npath.basename('path/to/file.txt', '.TXT'); // 'file.txt'\n\n  \n\n// 返回目录名，忽略尾部分隔符\n\npath.dirname('path/to/file.txt'); // 'path/to'\n\n  \n\n// 返回后缀名\n\npath.extname('path/to/file.txt'); // '.txt'\n\npath.extname('.minecraft'); // ''\n\npath.extname('file.'); // '.'\n\n  \n\n// 连接并规范path，忽略零长度的 path 片段。\n\npath.join('/foo', './bar', 'baz\\\\asdf', 'quux', '..'); // '\\foo\\bar\\baz\\asdf'\n\n// 如果连接的路径字符串最后是零长度字符串，则将返回当前工作目录\n\npath.join('foo/bar', '../../'); // '.\\'\n\n  \n\n// 将path解析为绝对路径并规范。从右到左处理，直到解析到绝对路径为止。注意盘符不会被忽略\n\npath.resolve('D:/test', '\\\\foo', 'bar', 'file'); // 'D:\\foo\\bar\\file'\n\n// 如果最终还没有生成绝对路径，则使用当前工作目录的绝对路径。\n\npath.resolve('test', 'static\\\\png\\\\', './../gif/image.gif');\n\n// 'C:\\Users\\a\\Desktop\\NodeStudy\\test\\static\\gif\\image.gif'\n\n  \n\n// 返回一个含有path重要元素的对象，与path.format为互逆操作，注意该方法不会规范化\n\nconst pathObj = path.parse(path.normalize('/home/user/dir/file.txt'));\n\n// { root: '\\\\',\n\n//   dir: '\\\\home\\\\user\\\\dir',\n\n//   base: 'file.txt',\n\n//   ext: '.txt',\n\n//   name: 'file' }\n\npath.format(pathObj); // \\home\\user\\dir\\file.txt\n\n  \n\n// 返回从from到to的相对路径，若from和to相同则返回空字符串\n\npath.relative('C:/test1/aaa', 'C:\\\\test2\\\\bbb'); // '..\\..\\test2\\bbb'\n\n// 若存在相对路径或空字符串，则以当前工作目录为基准。\n\npath.relative('', 'C:/test1/aaa'); // '..\\..\\..\\..\\test1\\aaa'\n\n  \n\n// 返回是否为绝对路径\n\npath.isAbsolute('/foo/bar/'); // true\n```"
}